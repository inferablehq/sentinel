"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.blob = exports.extractBlobs = exports.BLOB_DATA_KEY = exports.isZodType = exports.ajvErrorToFailures = exports.validateFunctionSchema = exports.validateDescription = exports.validatePropertyName = exports.validateFunctionName = exports.validateServiceName = void 0;
const errors_1 = require("./errors");
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const zod_1 = require("zod");
const contract_1 = require("./contract");
// Name restriction for Services and Functions
const ALLOWED_NAME_CHARACTERS = /^[a-zA-Z0-9]+$/;
const MAX_NAME_LENGTH = 30;
const validateServiceName = (name) => {
    if (!ALLOWED_NAME_CHARACTERS.test(name)) {
        throw new errors_1.InferableError(`Service name must only contain letters and numbers. Got: ${name}`);
    }
    if (name.length > MAX_NAME_LENGTH) {
        throw new errors_1.InferableError(`Service name must be less than ${MAX_NAME_LENGTH} characters: Got ${name} with length ${name.length}.`);
    }
};
exports.validateServiceName = validateServiceName;
const validateFunctionName = (name) => {
    if (!ALLOWED_NAME_CHARACTERS.test(name)) {
        throw new errors_1.InferableError(`Function name must only contain letters and numbers. Got: ${name}`);
    }
};
exports.validateFunctionName = validateFunctionName;
const validatePropertyName = (name) => {
    const ALLOWED_PROPERTY_NAME_CHARACTERS = /^[a-zA-Z0-9_]+$/;
    if (!ALLOWED_PROPERTY_NAME_CHARACTERS.test(name)) {
        throw new errors_1.InferableError(`Property name must only contain letters, numbers and underscore '_'. Got: ${name}`);
    }
};
exports.validatePropertyName = validatePropertyName;
const validateDescription = (description) => {
    if (description === "") {
        throw new errors_1.InferableError("Description must not be empty");
    }
};
exports.validateDescription = validateDescription;
/*
 * Validate a function schema.
 */
const validateFunctionSchema = (input) => {
    delete input.properties?.undefined;
    if (!input || !input.properties) {
        return [{ path: "", error: "Schema must be defined" }];
    }
    const errors = Object.keys(input.properties)
        .map((key) => {
        return validateProperty(key, input.properties[key]);
    })
        .flat();
    if (errors.length > 0) {
        return errors;
    }
    const ajv = new ajv_1.default();
    (0, ajv_formats_1.default)(ajv);
    try {
        ajv.compile({
            ...input,
            $schema: undefined,
        });
    }
    catch (error) {
        if (error instanceof Error) {
            return (0, exports.ajvErrorToFailures)(error);
        }
        throw new errors_1.InferableError("Unknown JSON schema compilation error", {
            error,
        });
    }
    return [];
};
exports.validateFunctionSchema = validateFunctionSchema;
/**
 * Recursively validate $.properties
 */
const validateProperty = (key, value) => {
    let errors = [];
    try {
        (0, exports.validatePropertyName)(key);
    }
    catch (error) {
        if (error instanceof Error) {
            errors.push({
                path: `${key}`,
                error: error.message,
            });
        }
        else {
            throw error;
        }
    }
    if (value && typeof value === "object" && "properties" in value) {
        const properties = value.properties || {};
        errors = errors.concat(Object.keys(properties)
            .map((key) => {
            return validateProperty(key, properties[key]);
        })
            .flat());
    }
    return errors;
};
/*
 * Accepts an AJV compilation error and extracts the error details from the message.
 */
const ajvErrorToFailures = (error) => {
    const INVALID_MESSAGE_PREFIX = "schema is invalid:";
    // example: /data/properties/name some error message
    if (!error.message.startsWith(INVALID_MESSAGE_PREFIX)) {
        throw new errors_1.InferableError("Could not extract failures from AJV error", {
            error,
        });
    }
    return error.message
        .replace(INVALID_MESSAGE_PREFIX, "")
        .split(",")
        .map((s) => s.trim())
        .map((s) => {
        const firstSpace = s.indexOf(" ");
        if (firstSpace === -1) {
            throw new errors_1.InferableError("Could not extract failures from AJV error", {
                error,
            });
        }
        return {
            path: s.slice(0, firstSpace),
            error: s.slice(firstSpace + 1),
        };
    });
};
exports.ajvErrorToFailures = ajvErrorToFailures;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isZodType = (input) => {
    return input?._def?.typeName;
};
exports.isZodType = isZodType;
exports.BLOB_DATA_KEY = "__inferable_blob_data";
const extractBlobs = (content) => {
    if (!content || typeof content !== "object") {
        return {
            blobs: [],
            content,
        };
    }
    const keys = Object.keys(content);
    if (keys.length === 0) {
        return {
            blobs: [],
            content,
        };
    }
    const blobs = {};
    for (const key of keys) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const value = content[key];
        if (value && typeof value === "object" && exports.BLOB_DATA_KEY in value) {
            const parsedBlob = blobExtractionSchema.safeParse(value[exports.BLOB_DATA_KEY]);
            if (!parsedBlob.success) {
                console.error(parsedBlob.error);
                throw new errors_1.InferableError("Found invalid Blob data");
            }
            blobs[key] = parsedBlob.data;
        }
    }
    return {
        blobs: Object.values(blobs),
        content: Object.fromEntries(Object.entries(content).filter(([key]) => !blobs[key])),
    };
};
exports.extractBlobs = extractBlobs;
const blobExtractionSchema = contract_1.blobSchema
    .omit({
    id: true,
    createdAt: true,
})
    .and(zod_1.z.object({
    data: zod_1.z.string(),
}));
const blob = ({ name, data }) => {
    let type = "json";
    if (Array.isArray(data)) {
        type = "json-array";
    }
    const encoded = Buffer.from(JSON.stringify(data)).toString("base64");
    return {
        [exports.BLOB_DATA_KEY]: {
            name,
            type,
            encoding: "base64",
            data: encoded,
            size: Buffer.from(encoded).byteLength,
        },
    };
};
exports.blob = blob;
//# sourceMappingURL=util.js.map