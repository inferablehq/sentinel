"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Inferable = exports.log = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = __importDefault(require("path"));
const zod_to_json_schema_1 = __importDefault(require("zod-to-json-schema"));
const errors_1 = require("./errors");
const machine_id_1 = require("./machine-id");
const service_1 = require("./service");
const util_1 = require("./util");
const links = __importStar(require("./links"));
// Custom json formatter
debug_1.default.formatters.J = (json) => {
    return JSON.stringify(json, null, 2);
};
exports.log = (0, debug_1.default)("inferable:client");
/**
 * The Inferable client. This is the main entry point for using Inferable.
 *
 * Inferable client exposes two main methods:
 * * `service` - Registers a service with Inferable.
 * * `workflow` - Starts a workflow with Inferable
 *
 * @example Basic usage
 * ```ts
 * // src/service.ts
 *
 * // create a new Inferable instance
 * const d = new Inferable({
 *  apiSecret: "API_SECRET",
 * });
 *
 * const myService = d.service({
 *   name: "my-service",
 * });
 *
 * myService.register("hello", z.object({name: z.string()}), async ({name}: {name: string}) => {
 *  return `Hello ${name}`;
 * })
 *
 * await myService.start();
 *
 * // stop the service on shutdown
 * process.on("beforeExit", async () => {
 *   await myService.stop();
 * });
 *
 * ```
 */
class Inferable {
    static getMachineId() {
        return (0, machine_id_1.machineId)();
    }
    static getVersion() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        return require(path_1.default.join(__dirname, "..", "package.json")).version;
    }
    /**
     * Initializes a new Inferable instance.
     * @param apiSecret The API Secret for your Inferable cluster. If not provided, it will be read from the `INFERABLE_API_SECRET` environment variable.
     * @param options Additional options for the Inferable client.
     * @param options.endpoint The endpoint for the Inferable cluster. Defaults to https://api.inferable.ai.
     *
     * @example
     * ```ts
     * // Basic usage
     * const d = new Inferable({
     *  apiSecret: "API_SECRET",
     * });
     *
     * // OR
     *
     * process.env.INFERABLE_API_SECRET = "API_SECRET";
     * const d = new Inferable();
     *
     *
     * // With encryption
     * const d = new Inferable({
     *  encryptionKeys: [
     *    Buffer.from("abcdefghijklmnopqrstuvwxzy123456"), // current key
     *    Buffer.from("abcdefghijklmnopqrstuvwxzy123old"), // previous key
     *  ],
     * });
     * ```
     */
    constructor(options) {
        this.services = [];
        this.functionRegistry = {};
        if (options?.apiSecret && process.env.INFERABLE_API_SECRET) {
            (0, exports.log)("API Secret was provided as an option and environment variable. Constructor argument will be used.");
        }
        const apiSecret = options?.apiSecret || process.env.INFERABLE_API_SECRET;
        if (!apiSecret) {
            throw new errors_1.InferableError(`No API Secret provided. Please see ${links.DOCS_AUTH}`);
        }
        if (!apiSecret.startsWith("sk_cluster_machine")) {
            if (apiSecret.startsWith("sk_")) {
                throw new errors_1.InferableError(`Provided non-Machine API Secret. Please see ${links.DOCS_AUTH}`);
            }
            throw new errors_1.InferableError(`Invalid API Secret. Please see ${links.DOCS_AUTH}`);
        }
        this.apiSecret = apiSecret;
        this.endpoint =
            options?.endpoint ||
                process.env.INFERABLE_API_ENDPOINT ||
                "https://api.inferable.ai";
        this.machineId = (0, machine_id_1.machineId)();
    }
    /**
     * An array containing the name of all services currently polling.
     */
    get activeServices() {
        return this.services.filter((s) => s.polling).map((s) => s.name);
    }
    /**
     * An array containing the name of all services not currently polling.
     *
     * Note that this will only include services which have been started (`.start()` called).
     */
    get inactiveServices() {
        return this.services.filter((s) => !s.polling).map((s) => s.name);
    }
    /**
     * An array containing the name of all functions which have been registered.
     */
    get registeredFunctions() {
        return Object.values(this.functionRegistry).map((f) => f.name);
    }
    /**
     * Convenience reference to a service with name 'default'.
     * @returns A registered service instance.
     * @see {@link service}
     * @example
     * ```ts
     * const d = new Inferable({apiSecret: "API_SECRET"});
     *
     * d.default.register("hello", z.object({name: z.string()}), async ({name}: {name: string}) => {
     *   return `Hello ${name}`;
     * });
     *
     * // start the service
     * await d.default.start();
     *
     * // stop the service on shutdown
     * process.on("beforeExit", async () => {
     *   await d.default.stop();
     * });
     *
     */
    get default() {
        return this.service({
            name: "default",
        });
    }
    /**
     * Registers a service with Inferable. This will register all functions on the service.
     * @param input The service definition.
     * @returns A registered service instance.
     * @example
     * ```ts
     * const d = new Inferable({apiSecret: "API_SECRET"});
     *
     * const service = d.service({
     *   name: "my-service",
     * });
     *
     * service.register("hello", z.object({name: z.string()}), async ({name}: {name: string}) => {
     *   return `Hello ${name}`;
     * });
     *
     * // start the service
     * await service.start();
     *
     * // stop the service on shutdown
     * process.on("beforeExit", async () => {
     *   await service.stop();
     * });
     * ```
     */
    service(input) {
        (0, util_1.validateServiceName)(input.name);
        const register = ({ name, func, schema, config, description, authenticate, }) => {
            this.registerFunction({
                name,
                authenticate,
                serviceName: input.name,
                func,
                inputSchema: schema.input,
                config,
                description,
            });
        };
        return {
            definition: input,
            register,
            start: async () => {
                const functions = await input.functions;
                functions?.forEach(register);
                const existing = this.services.find((service) => service.name == input.name);
                if (existing) {
                    throw new errors_1.InferableError(`Service is already started`, {
                        serviceName: input.name,
                    });
                }
                const serivce = new service_1.Service({
                    endpoint: this.endpoint,
                    machineId: this.machineId,
                    apiSecret: this.apiSecret,
                    service: input.name,
                    functions: Object.values(this.functionRegistry).filter((f) => f.serviceName == input.name),
                });
                this.services.push(serivce);
                await serivce.start();
            },
            stop: async () => {
                const existing = this.services.find((service) => service.name == input.name);
                if (!existing) {
                    throw new errors_1.InferableError(`Service is not started`, {
                        serviceName: input.name,
                    });
                }
                await existing.stop();
            },
        };
    }
    /**
     * The cluster ID for this Inferable instance.
     */
    get clusterId() {
        return this.services[0]?.clusterId || null;
    }
    registerFunction({ name, authenticate, serviceName, func, inputSchema, config, description, }) {
        if (this.functionRegistry[name]) {
            throw new errors_1.InferableError(`Function name '${name}' is already registered by another service.`);
        }
        // We accept both Zod types and JSON schema as an input, convert to JSON schema if the input is a Zod type
        const inputJson = ((0, util_1.isZodType)(inputSchema) ? (0, zod_to_json_schema_1.default)(inputSchema) : inputSchema);
        (0, util_1.validateFunctionName)(name);
        (0, util_1.validateDescription)(description);
        const schemaErrors = (0, util_1.validateFunctionSchema)(inputJson);
        if (schemaErrors.length > 0) {
            (0, exports.log)(`Schema ${serviceName}${name} failed validation: %J with failures %O`, inputSchema, schemaErrors);
            throw new errors_1.InferableError(`JSON schema was not valid for service '${serviceName}.${name}'. Run with debug logging (DEBUG=inferable:*) for more details.`, {
                failures: schemaErrors,
            });
        }
        const registration = {
            name,
            authenticate,
            serviceName,
            func,
            schema: {
                input: inputSchema,
                inputJson: JSON.stringify(inputJson),
            },
            config,
            description,
        };
        const existing = this.services.find((service) => service.name == serviceName);
        if (existing) {
            throw new errors_1.InferableError(`Functions must be registered before starting the service. Please see ${links.DOCS_FUNCTIONS}`, {
                serviceName: registration.serviceName,
            });
        }
        if (typeof registration.func !== "function") {
            throw new errors_1.InferableError(`func must be a function. Please see ${links.DOCS_FUNCTIONS}`);
        }
        (0, exports.log)(`Registering function`, {
            name: registration.name,
        });
        this.functionRegistry[registration.name] = registration;
    }
}
exports.Inferable = Inferable;
//# sourceMappingURL=Inferable.js.map