"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = exports.log = void 0;
const debug_1 = __importDefault(require("debug"));
const zod_1 = require("zod");
const create_client_1 = require("./create-client");
const errors_1 = require("./errors");
const serialize_error_1 = require("./serialize-error");
const execute_fn_1 = require("./execute-fn");
const util_1 = require("./util");
const MAX_CONSECUTIVE_POLL_FAILURES = 50;
const DEFAULT_RETRY_AFTER_SECONDS = 10;
exports.log = (0, debug_1.default)("inferable:client:polling-agent");
class Service {
    constructor(options) {
        this.clusterId = null;
        this.polling = false;
        this.functions = [];
        this.retryAfter = DEFAULT_RETRY_AFTER_SECONDS;
        this.name = options.service;
        this.client = (0, create_client_1.createApiClient)({
            baseUrl: options.endpoint,
            machineId: options.machineId,
            apiSecret: options.apiSecret,
        });
        this.functions = options.functions;
    }
    async start() {
        (0, exports.log)("Starting polling agent", { service: this.name });
        const { clusterId } = await this.registerMachine();
        this.clusterId = clusterId;
        this.polling = true;
        // Purposefully not awaited
        this.runLoop();
        return {
            clusterId,
        };
    }
    async stop() {
        (0, exports.log)("Stopping polling agent", { service: this.name });
        this.polling = false;
    }
    async registerMachine() {
        (0, exports.log)("registering machine", {
            service: this.name,
            functions: this.functions.map((f) => f.name),
        });
        const registerResult = await this.client.createMachine({
            headers: {
                "x-sentinel-no-mask": "1",
            },
            body: {
                service: this.name,
                functions: this.functions.map((func) => ({
                    name: func.name,
                    description: func.description,
                    schema: func.schema.inputJson,
                    config: func.config,
                })),
            },
        });
        if (registerResult?.status !== 200) {
            (0, exports.log)("Failed to register machine", registerResult);
            throw new errors_1.InferableError("Failed to register machine", {
                status: registerResult.status,
                body: registerResult.body,
            });
        }
        return {
            clusterId: registerResult.body.clusterId,
        };
    }
    async runLoop() {
        let failureCount = 0;
        while (this.polling && failureCount < MAX_CONSECUTIVE_POLL_FAILURES) {
            try {
                await this.pollIteration();
            }
            catch (e) {
                (0, exports.log)("Failed poll iteration", e);
                failureCount++;
            }
            await new Promise((resolve) => setTimeout(resolve, this.retryAfter * 1000));
        }
        (0, exports.log)("Quitting polling agent", { service: this.name, failureCount });
    }
    async pollIteration() {
        if (!this.clusterId) {
            throw new Error("Failed to poll. Could not find clusterId");
        }
        const pollResult = await this.client.listCalls({
            params: {
                clusterId: this.clusterId,
            },
            query: {
                service: this.name,
                status: "pending",
                acknowledge: true,
                limit: 10,
            },
        });
        const retryAfterHeader = pollResult.headers.get("retry-after");
        if (retryAfterHeader && !isNaN(Number(retryAfterHeader))) {
            this.retryAfter = Number(retryAfterHeader);
        }
        if (pollResult?.status !== 200) {
            throw new errors_1.InferableError("Failed to fetch calls", {
                status: pollResult?.status,
                body: pollResult?.body,
            });
        }
        await Promise.all(pollResult.body.map(async (job) => {
            await this.processCall(job);
        }));
    }
    async processCall(call) {
        const registration = this.functions.find((fn) => fn.name === call.function);
        if (!registration) {
            (0, exports.log)("Received call for unknown function", {
                service: this.name,
                function: call.function,
            });
            return;
        }
        (0, exports.log)("Executing job", {
            id: call.id,
            function: call.function,
            registered: !!registration,
        });
        const onComplete = async (result) => {
            (0, exports.log)("Persisting job result", {
                id: call.id,
                function: call.function,
                resultType: result.type,
                functionExecutionTime: result.functionExecutionTime,
            });
            const contentAndBlobs = (0, util_1.extractBlobs)(result.content);
            const persistResult = this.client
                .createCallResult({
                headers: {
                    "x-sentinel-unmask-keys": "resultType,functionExecutionTime",
                },
                body: {
                    result: contentAndBlobs.content,
                    resultType: result.type,
                    meta: {
                        functionExecutionTime: result.functionExecutionTime,
                    },
                },
                params: {
                    callId: call.id,
                    clusterId: this.clusterId,
                },
            })
                .then(async (res) => {
                if (res.status === 204) {
                    (0, exports.log)("Completed job", call.id, call.function);
                }
                else {
                    throw new errors_1.InferableError(`Failed to persist call: ${res.status}`, {
                        jobId: call.id,
                        body: res.body,
                    });
                }
            });
            const persistBlobs = contentAndBlobs.blobs.map((blob) => this.client.createBlob({
                headers: {
                    "x-sentinel-no-mask": "1",
                },
                params: {
                    jobId: call.id,
                },
                body: blob,
            }));
            await Promise.all([persistResult, ...persistBlobs]);
        };
        const args = call.input;
        (0, exports.log)("Executing fn", {
            id: call.id,
            function: call.function,
            registeredFn: registration.func,
            args,
        });
        if (typeof args !== "object" || Array.isArray(args) || args === null) {
            (0, exports.log)("Function was called with invalid invalid format. Expected an object.", {
                function: call.function,
                service: this.name,
            });
            return onComplete({
                type: "rejection",
                content: (0, serialize_error_1.serializeError)(new Error("Function was called with invalid invalid format. Expected an object.")),
                functionExecutionTime: 0,
            });
        }
        try {
            registration.schema.input.parse(args);
        }
        catch (e) {
            if (e instanceof zod_1.z.ZodError) {
                e.errors.forEach((error) => {
                    (0, exports.log)("Function input does not match schema", {
                        function: call.function,
                        path: error.path,
                        error: error.message,
                    });
                });
            }
            return onComplete({
                type: "rejection",
                content: (0, serialize_error_1.serializeError)(e),
                functionExecutionTime: 0,
            });
        }
        const result = await (0, execute_fn_1.executeFn)(registration.func, [args], registration.authenticate);
        await onComplete(result);
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map