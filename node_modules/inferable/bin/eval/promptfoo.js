"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const create_client_1 = require("../create-client");
const zod_1 = require("zod");
const errors_1 = require("../errors");
const links = __importStar(require("../links"));
const mocksSchema = zod_1.z.record(zod_1.z.object({
    output: zod_1.z.object({}).passthrough(),
}));
const inputSchema = zod_1.z.object({
    message: zod_1.z.string().optional(),
    // JSON string of of mock results
    mocks: zod_1.z.string().optional(),
    template: zod_1.z
        .object({
        id: zod_1.z.string(),
        input: zod_1.z.record(zod_1.z.string()),
    })
        .optional(),
});
class InferablePromptfooProvider {
    constructor() {
        this.callApi = async (rawInput, _context, _options) => {
            // Check if prompt is JSON string
            let message;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let inputObject;
            try {
                inputObject = JSON.parse(rawInput);
            }
            catch {
                // Expected if prompt is not JSON, we will treat it as a message
                message = rawInput;
            }
            let input;
            if (inputObject) {
                try {
                    input = inputSchema.parse(inputObject);
                }
                catch (e) {
                    throw new Error(`Invalid evaluation input: ${e}`);
                }
            }
            let parsedMocks;
            if (!!input?.mocks) {
                try {
                    parsedMocks = mocksSchema.parse(JSON.parse(input.mocks));
                }
                catch (e) {
                    throw new Error(`Invalid mocks provided: ${e}`);
                }
            }
            const run = await this.run({
                ...(input ? input : { message }),
                test: {
                    enabled: true,
                    mocks: parsedMocks,
                },
            });
            const result = await this._pollRun(run);
            return {
                output: {
                    ...result,
                },
            };
        };
        this.providerId = "InferableProvider";
        this.controlPlaneClient = (0, create_client_1.createApiClient)({});
        if (!process.env.INFERABLE_API_SECRET) {
            throw new errors_1.InferableError(`No API Secret provided. Please see ${links.DOCS_AUTH}`);
        }
        this.apiSecret = process.env.INFERABLE_API_SECRET;
    }
    id() {
        return this.providerId;
    }
    async _pollRun(run, attempts = 0) {
        if (attempts > 10) {
            throw new Error("Failed to fetch run after 10 attempts");
        }
        await new Promise((resolve) => setTimeout(resolve, attempts * 5000));
        const details = await run.fetchDetails();
        const terminalStatuses = ["done", "failed"];
        if (details.run.status) {
            const done = terminalStatuses.includes(details.run.status) ||
                details.inputRequests.length > 0;
            if (done) {
                return {
                    id: details.run.id,
                    status: details.run.status,
                    failureReason: details.run.failureReason,
                    messages: (await run.fetchMessages()).map((m) => ({
                        type: m.type,
                        data: m.data,
                    })),
                    jobs: details.jobs.map((j) => ({
                        id: j.id,
                        status: j.status,
                        service: j.service,
                        function: j.targetFn,
                    })),
                    inputRequests: details.inputRequests.map((r) => ({
                        id: r.id,
                    })),
                };
            }
        }
        return await this._pollRun(run, attempts + 1);
    }
    /**
     * (Starts a new / fetch existing) runs with Inferable.
     * This function can not be called with a machine token.
     * It requires a User token, this can be obtained using the CLI.
     *
     * @returns A reference to the run which can be used to fetch the run details and messages.
     */
    async run({ test = {
        enabled: false,
    }, message, template, runId, }) {
        if (!process.env.INFERABLE_CLUSTER_ID) {
            throw new errors_1.InferableError("INFERABLE_CLUSTER_ID must be set to start a run");
        }
        if (this.apiSecret.startsWith("sk_")) {
            throw new errors_1.InferableError("This function can not be called with a machine token. Please use a User token which can be obtained using the `inferable auth login` command.");
        }
        const clusterId = process.env.INFERABLE_CLUSTER_ID;
        // Fetch existing run
        if (runId) {
            if (!!message) {
                throw new errors_1.InferableError("Cannot specify both existing runId and message");
            }
            if (!!template) {
                throw new errors_1.InferableError("Cannot specify both existing runId and template");
            }
            const result = await this.controlPlaneClient.getRun({
                params: {
                    clusterId,
                    runId,
                },
                headers: {
                    authorization: this.apiSecret,
                },
            });
            if (result.status !== 200) {
                throw new errors_1.InferableError("Failed to fetch run details", result);
            }
        }
        else {
            // Create a new
            const result = await this.controlPlaneClient.createRun({
                body: {
                    test,
                    message,
                    template: template,
                },
                params: {
                    clusterId,
                },
                headers: {
                    authorization: this.apiSecret,
                },
            });
            if (result.status !== 201) {
                throw new errors_1.InferableError("Failed to start run", result);
            }
            runId = result.body.id;
        }
        return {
            runId,
            submitFeedback: async (feedback) => {
                const result = await this.controlPlaneClient.createFeedback({
                    body: feedback,
                    params: {
                        clusterId,
                        runId,
                    },
                    headers: {
                        authorization: this.apiSecret,
                    },
                });
                if (result.status !== 204) {
                    throw new errors_1.InferableError("Failed to submit feedback for run");
                }
            },
            fetchDetails: async () => {
                const result = await this.controlPlaneClient.getRunTimeline({
                    params: {
                        clusterId,
                        runId,
                    },
                    headers: {
                        authorization: this.apiSecret,
                    },
                });
                if (result.status !== 200) {
                    throw new errors_1.InferableError(`Failed to fetch run ${runId}`);
                }
                return result.body;
            },
            fetchMessages: async () => {
                const result = await this.controlPlaneClient.listMessages({
                    params: {
                        clusterId,
                        runId,
                    },
                    headers: {
                        authorization: this.apiSecret,
                    },
                });
                if (result.status !== 200) {
                    throw new errors_1.InferableError(`Failed to fetch run messages ${runId}`);
                }
                return result.body;
            },
        };
    }
}
module.exports = InferablePromptfooProvider;
//# sourceMappingURL=promptfoo.js.map